"""Agent state management for LangGraph cognitive architecture."""

import operator
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID, uuid4

from langchain_core.messages import BaseMessage
from langgraph.graph import add_messages
from pydantic import BaseModel, Field

from sovereign_career_architect.core.models import (
    ActionResult,
    ExecutionPlan,
    InterruptState,
    UserProfile,
)


class AgentState(BaseModel):
    """
    Global state object for the LangGraph cognitive architecture.
    
    This state persists across all graph nodes and accumulates context
    as the agent moves through its execution cycle.
    """
    
    # Core conversation state
    messages: Annotated[List[BaseMessage], add_messages] = Field(
        default_factory=list,
        description="Appended history of all interactions in the current session"
    )
    
    # User context
    user_id: UUID = Field(
        default_factory=uuid4,
        description="Unique identifier for the current user"
    )
    
    session_id: UUID = Field(
        default_factory=uuid4,
        description="Unique identifier for the current session"
    )
    
    user_profile: Optional[UserProfile] = Field(
        None,
        description="Structured data retrieved from Mem0 (skills, goals, preferences)"
    )
    
    # Planning and execution
    current_plan: Optional[ExecutionPlan] = Field(
        None,
        description="The current execution plan generated by the Planner Node"
    )
    
    current_step_index: int = Field(
        0,
        description="Index of the currently executing step in the plan"
    )
    
    # Tool execution results
    tool_outputs: List[ActionResult] = Field(
        default_factory=list,
        description="Raw data captured by the Executor Node from tool executions"
    )
    
    # Self-reflection and improvement
    critique: Optional[str] = Field(
        None,
        description="Output of the Reviewer Node containing specific feedback on performance"
    )
    
    # Error handling and retry logic
    retry_count: int = Field(
        0,
        description="Counter to prevent infinite loops during error recovery"
    )
    
    max_retries: int = Field(
        3,
        description="Maximum number of retry attempts before escalation"
    )
    
    # Human-in-the-loop state
    interrupt_state: Optional[InterruptState] = Field(
        None,
        description="Current interrupt state for human approval workflows"
    )
    
    # Memory context
    memory_context: Dict[str, Any] = Field(
        default_factory=dict,
        description="Retrieved memories and context from Mem0"
    )
    
    # Node routing
    next_node: Optional[str] = Field(
        None,
        description="Next node to execute in the graph"
    )
    
    # Execution metadata
    execution_metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Metadata about the current execution context"
    )
    
    # Voice interaction state
    voice_active: bool = Field(
        False,
        description="Whether voice interaction is currently active"
    )
    
    language: str = Field(
        "en",
        description="Current interaction language (ISO 639-1 code)"
    )
    
    # Browser automation state
    browser_session_active: bool = Field(
        False,
        description="Whether a browser automation session is active"
    )
    
    current_url: Optional[str] = Field(
        None,
        description="Current URL in browser automation session"
    )
    
    model_config = {"arbitrary_types_allowed": True}
        
    def add_tool_output(self, result: ActionResult) -> None:
        """Add a tool execution result to the state."""
        self.tool_outputs.append(result)
        
    def increment_retry(self) -> bool:
        """
        Increment retry counter and return whether max retries exceeded.
        
        Returns:
            True if max retries exceeded, False otherwise
        """
        self.retry_count += 1
        return self.retry_count >= self.max_retries
        
    def reset_retry_count(self) -> None:
        """Reset the retry counter."""
        self.retry_count = 0
        
    def set_interrupt(self, reason: str, action_summary: str) -> None:
        """Set an interrupt state for human approval."""
        self.interrupt_state = InterruptState(
            reason=reason,
            action_summary=action_summary,
            requires_approval=True
        )
        
    def clear_interrupt(self) -> None:
        """Clear the current interrupt state."""
        self.interrupt_state = None
        
    def is_interrupted(self) -> bool:
        """Check if the agent is currently interrupted."""
        return (
            self.interrupt_state is not None 
            and self.interrupt_state.approved is None
        )
        
    def get_current_step(self) -> Optional[Any]:
        """Get the current step from the execution plan."""
        if (
            self.current_plan 
            and self.current_step_index < len(self.current_plan.steps)
        ):
            return self.current_plan.steps[self.current_step_index]
        return None
        
    def advance_step(self) -> bool:
        """
        Advance to the next step in the execution plan.
        
        Returns:
            True if there are more steps, False if plan is complete
        """
        if self.current_plan:
            self.current_step_index += 1
            return self.current_step_index < len(self.current_plan.steps)
        return False
        
    def get_context_summary(self) -> Dict[str, Any]:
        """Get a summary of the current state for logging/debugging."""
        return {
            "user_id": str(self.user_id),
            "session_id": str(self.session_id),
            "messages_count": len(self.messages),
            "has_user_profile": self.user_profile is not None,
            "has_current_plan": self.current_plan is not None,
            "current_step_index": self.current_step_index,
            "tool_outputs_count": len(self.tool_outputs),
            "retry_count": self.retry_count,
            "is_interrupted": self.is_interrupted(),
            "voice_active": self.voice_active,
            "language": self.language,
            "browser_active": self.browser_session_active,
        }


# Type alias for state updates
StateUpdate = Dict[str, Any]